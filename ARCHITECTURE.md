# Architectural Specification and Implementation Handbook: RCompare

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [System Architecture and Workspace Design](#2-system-architecture-and-workspace-design)
3. [Core Library Specification](#3-core-library-specification-rcompare_core)
4. [User Interface Architecture](#4-user-interface-architecture-rcompare_gui--slint)
5. [Feature Parity Specifications](#5-feature-parity-specifications)
6. [Initial Development Plan](#6-initial-development-plan-roadmap)
7. [Technical Deep Dive](#7-technical-deep-dive-implementation-details)
8. [Testing Strategy](#8-testing-strategy)
9. [Security Considerations](#9-security-considerations)
10. [Performance Benchmarking](#10-performance-benchmarking)
11. [Conclusion](#11-conclusion)
12. [Appendix](#12-appendix-requirements-for-ai-generation-claude-code)

---

## 1. Executive Summary

### 1.1 Project Mandate and Scope

This document serves as the authoritative requirements specification and initial development plan for **RCompare**, an open-source, high-performance file and directory comparison utility. The project is conceived as a modern, memory-safe alternative to the industry-standard Beyond Compare, engineered to replicate its core functional depth while adhering to the architectural principles of [Czkawka](https://github.com/qarmin/czkawka).

**Primary Objective:** Deliver a cross-platform application (Linux, Windows, macOS) that provides rigorous comparison capabilities for:
- Folders (directories)
- Text files
- Binary data
- Images

By leveraging the **Rust** programming language, the project targets "zero-cost abstractions," ensuring that high-level architectural modularity does not compromise runtime performance. The graphical user interface (GUI) will be constructed using **Slint**, a declarative UI toolkit that facilitates the creation of lightweight, native-looking interfaces, mirroring the "Krokiet" frontend found in the Czkawka ecosystem.

### 1.2 Design Philosophy: The Czkawka Model

The architectural direction of RCompare is strictly governed by the patterns established in the [qarmin/czkawka](https://github.com/qarmin/czkawka) repository. This entails a rigid separation of concerns where business logic is isolated from the presentation layer, allowing for multiple frontends (CLI, GUI) to share a unified "Core" library.

**Core Principles:**

**Memory Safety & Performance:**
- Written in safe Rust, utilizing strict ownership models to manage memory without garbage collection
- Unsafe code blocks restricted to FFI bindings (e.g., for system-level filesystem optimizations)
- All unsafe code must be rigorously documented, adhering to Czkawka's "almost 100% unsafe code free" policy

**Concurrency:**
- Heavy computational tasks (directory traversal, hashing, diff generation) must be parallelized
- Employ thread pools via `rayon` or `crossbeam` to saturate available CPU cores
- Critical requirement for handling large datasets typical of Beyond Compare use cases

**Privacy-First:**
- Strictly offline utility
- No telemetry, usage tracking, or "phone home" mechanisms
- Complete data sovereignty for users in secure or air-gapped environments

**Modularity:**
- Organized as a Cargo workspace
- `rcompare_core` remains a pure library with no windowing system dependencies
- Enables use in headless server environments or CI/CD pipelines

### 1.3 High-Level Feature Targets

The feature set is derived from a gap analysis between Czkawka's current capabilities (focused on cleaning/deduplication) and Beyond Compare's analytical suite:

| Feature Category | RCompare Target Capability | Reference / Inspiration |
|-----------------|---------------------------|------------------------|
| **Folder Comparison** | Side-by-side directory trees, timestamp alignment, hash verification, orphan detection | Beyond Compare Folder View |
| **Text Comparison** | Syntax-highlighted diffs, intra-line character highlighting, 3-way merge conflict resolution | Beyond Compare Text Merge |
| **Archive Handling** | Transparent treatment of ZIP, TAR, and 7Z archives as folders | Beyond Compare VFS |
| **Sync & Merge** | Bi-directional synchronization, 3-way folder merging, safety previews (Dry Run) | Beyond Compare Sync |
| **Visualizations** | Hex dumps for binary files, perceptual diffs for images | Czkawka Image/Video Tools |
| **Automation** | Robust CLI for scripting and headless reports | Czkawka CLI |

---2. System Architecture and Workspace DesignThe foundational architecture of RCompare utilizes a monorepo workspace structure. This design facilitates simultaneous development of the core logic and multiple frontends while enforcing strict dependency boundaries.2.1 Workspace HierarchyThe project will be initialized as a Cargo workspace defined in the root Cargo.toml. This mirrors the czkawka structure (czkawka_core, czkawka_cli, czkawka_gui, krokiet) to ensure consistent versioning and shared compilation artifacts.2.1.1 rcompare_commonThis library serves as the semantic glue of the application. It contains the shared type definitions, enums, and trait interfaces used by all other crates. By extracting these commonalities, we prevent cyclic dependencies between the Core and the GUI.Scope: Error types (RCompareError), Configuration structs (Settings), domain primitives (FileNode, DiffResult), and the Vfs trait definition.Dependencies: serde, chrono, uuid, thiserror.2.1.2 rcompare_core (The Engine)This crate encapsulates the entire business logic of the application. It is the "brain" of RCompare. It must compile without any GUI dependencies (e.g., no slint, winit, or gtk).Responsibilities:Filesystem Traversal: Recursive directory scanning and tree construction.Hashing & Caching: BLAKE3/CRC32 implementation and on-disk cache management (bin/json).Comparison Algorithms: Myers/Patience diff logic, binary comparisons, and image perceptual hashing.Virtual File System (VFS): Implementation of local and archive-based file access.Concurrency Model: It exposes synchronous APIs that internally manage thread pools, or asynchronous APIs using tokio channels for progress reporting.2.1.3 rcompare_gui (The Frontend)This crate implements the graphical user interface using Slint. It is responsible for window management, user input handling, and rendering the state provided by rcompare_core.Responsibilities:State Management: Mapping Rust data structures to Slint Models (VecModel, StandardListView).Event Handling: Capturing user actions (clicks, key presses) and dispatching commands to the Core.Rendering: Drawing the split-pane views, syntax-highlighted text, and diff visualizations.Design Pattern: It utilizes the "Krokiet" pattern—a standalone binary that embeds the Slint runtime.2.1.4 rcompare_cli (The Automation Tool)A command-line interface wrapper for rcompare_core. This ensures that all functionality available in the GUI can also be accessed via scripts, a critical feature for server-side verification tasks.Responsibilities: Argument parsing (clap), formatted text output (JSON/Table), and exit code management.2.2 Cross-Cutting Concerns2.2.1 Error Handling StrategyFollowing Rust best practices and Czkawka’s patterns, the application will use thiserror for library errors and anyhow for application-level error handling.Panic Policy: The Core library must never panic. All errors (I/O failures, permission denied, invalid encoding) must be propagated up to the caller.Logging: The application will use tracing (or log) to write structured logs to stderr (CLI) or a log file (GUI). This replaces the standard println! debugging to allow for cleaner production monitoring.2.2.2 Configuration ManagementSettings will be persisted using serde and toml. The configuration struct AppConfig will live in rcompare_common and will be loaded at startup.Locations: Adhering to the XDG Base Directory specification on Linux (~/.config/rcompare), AppData on Windows, and Library/Preferences on macOS, utilizing the directories crate.Portability: A portable mode (checking for rcompare.toml alongside the binary) will be implemented to support USB drive deployments, similar to Beyond Compare’s portable mode.3. Core Library Specification (rcompare_core)The Core library is the most complex component, requiring rigorous algorithmic implementations to match the speed and accuracy of existing tools.3.1 The Virtual File System (VFS) LayerBeyond Compare allows users to treat Zip files, FTP servers, and S3 buckets as standard directories. To achieve this, rcompare_core cannot simply use std::fs. It must abstract filesystem access behind a trait.3.1.1 VFS Trait DefinitionThe Vfs trait (defined in rcompare_common) abstracts the essential IO operations.Rustpub trait Vfs: Send + Sync {
    /// uniquely identifies the VFS instance (e.g., "local", "zip:archive.zip")
    fn instance_id(&self) -> &str;
    
    /// Returns the metadata for a specific path
    fn metadata(&self, path: &Path) -> Result<FileMetadata, VfsError>;
    
    /// Lists the contents of a directory
    fn read_dir(&self, path: &Path) -> Result<Vec<FileEntry>, VfsError>;
    
    /// Opens a file for reading (returns a Read trait object)
    fn open_file(&self, path: &Path) -> Result<Box<dyn Read + Send>, VfsError>;
    
    /// Basic operations for synchronization
    fn remove_file(&self, path: &Path) -> Result<(), VfsError>;
    fn copy_file(&self, src: &Path, dest: &Path) -> Result<(), VfsError>;
}
3.1.2 ImplementationsLocalVfs: A thin wrapper around std::fs and std::path. It will utilize the ignore or jwalk crates for efficient directory traversal, respecting .gitignore files if configured (a feature Czkawka supports).ArchiveVfs (Planned): A read-only VFS implementation utilizing the zip and tar crates. It maps the internal structure of an archive to a VFS path hierarchy. This allows the comparison engine to "dive into" archives transparently.3.2 Scanning and Tree ConstructionThe "Folder Compare" session requires building an in-memory representation of two directory trees to align them.3.2.1 The ScanSession LogicParallel Traversal: Using jwalk, the scanner traverses both Left and Right roots simultaneously.Alignment Strategy:The scanner produces a BTreeMap<PathBuf, FileNode>.Paths are relative to the scan root (e.g., src/main.rs).The alignment logic creates a DiffNode struct:Rustpub struct DiffNode {
    pub relative_path: PathBuf,
    pub left: Option<FileEntry>,  // None if Orphan Right
    pub right: Option<FileEntry>, // None if Orphan Left
    pub status: DiffStatus,       // Same, Different, Orphan
}
Memory Optimization: For massive directory trees (1M+ files), keeping full paths in memory consumes gigabytes. The Core will use internment or shared atomic reference counting (Arc<str>) for repeated path segments to reduce memory pressure.3.3 Hashing and CachingTo replicate Czkawka’s performance, RCompare must not re-hash files that haven’t changed.3.3.1 Hashing AlgorithmsFast Hash (Pre-check): Check file size. If different, stop. If same, read the first 16KB + middle 16KB + last 16KB (Partial Hash). This detects most changes instantly without reading the whole file.Full Hash (Verification): If partial hashes match, perform a full hash.Algorithm Choice: BLAKE3 is selected as the default. It is significantly faster than MD5/SHA256 and supports highly parallel hashing via SIMD, aligning with the project's performance goals.3.3.2 The Persistent Cache (bin/json)Following Czkawka’s format, the cache will be stored as cache_folder_compare.bin (using bincode for speed) or .json (for debuggability).Key: (AbsPath, ModifiedTime, FileSize)Value: HashInvalidation: On scan start, the cache is loaded. If a file's mtime or size differs from the cache key, the hash is invalidated and recomputed.3.4 Text Difference EngineThe ability to show accurate text diffs is the "killer feature" of the application.3.4.1 Algorithm SelectionThe Core will integrate the similar crate, which provides robust implementations of:Myers: The standard "greedy" diff algorithm. Fast, but can produce "confusing" diffs for code.Patience: The preferred algorithm for source code. It aligns unique lines first (like function headers), resulting in much cleaner, semantic diffs.LCS (Longest Common Subsequence): Useful for intra-line highlighting.3.4.2 Intra-Line DiffingWhen two lines differ, the engine must perform a second pass.Line Diff: Identifies that Line 10 changed from let x = 5; to let x = 6;.Character Diff: runs a Myers diff on the character sequences of those two lines.Result: The UI receives a data structure indicating that 5 was deleted and 6 was added, allowing for precise background coloring (e.g., dark red for the line, bright red for the specific character).4. User Interface Architecture (rcompare_gui / Slint)Slint is a declarative framework. Unlike GTK, it does not rely on GObject signals but on property bindings and callbacks. The UI architecture must adapt to this reactive model.4.1 Layout and WindowingThe main application window will use a VerticalBox layout containing:MenuBar: Standard menus (File, Edit, View).Toolbar: Icon-based shortcuts for common actions (Refresh, Up Level, Expand All).SessionTabs: A TabWidget to hold multiple active comparisons.StatusPanel: A footer showing selection stats ("5 files selected, 2.4MB").4.2 The "Virtual Tree" ChallengeSlint currently lacks a high-performance, native TreeView widget capable of handling 100k+ items efficiently. Rendering recursively nested generic components is performantly prohibitive.Solution: Flattened Virtual ListWe will implement the TreeView as a StandardListView (or a custom ListView) backed by a linear VecModel.Rust Side: The Tree structure is flattened into a Vec<RowData>.Each RowData contains a depth: i32 field and an is_expanded: bool field.When a user "collapses" a node, the backend removes the descendants from the VecModel.When a user "expands" a node, the backend inserts the descendants into the VecModel.Slint Side: The ListView delegate (row renderer) uses the depth property to calculate the indentation (x: depth * 20px).Visuals: A helper Image element displays a generic "folder" or "file" icon, and a "chevron" icon rotates based on the is_expanded state.4.3 Synchronized ScrollingFor side-by-side comparison, scrolling the Left panel must scroll the Right panel.Implementation: Slint allows property binding. We will bind the viewport-y property of both ListViews to a shared root property shared_viewport_y.Center Gutter: A central column (between Left and Right) will render the "thumbnail" map of differences (red/blue lines) to give the user a high-level overview of where changes exist in the file.4.4 Syntax Highlighting & Text RenderingSlint does not have a "Rich Text" widget that supports complex spans (e.g., <span color="red">foo</span><span color="blue">bar</span>) natively and efficiently for large documents.Strategy: The syntect BridgeAnalysis: The rcompare_core uses syntect to parse the code and generate a list of tokens and colors.Render Model: Instead of creating thousands of Slint Text widgets (which is slow), we will render the syntax-highlighted line into a pixel buffer (Image) on the Rust side using a lightweight renderer (like resvg or basic bitmap drawing), or break the line into a limited number of Text segments if the token count is low.Hybrid Approach: For the active line (where the cursor is), we render individual Text elements to allow selection. For passive lines, we render a cached Image strip. This hybrid approach balances memory usage with rendering performance.5. Feature Parity Specifications5.1 Folder Comparison FeaturesOrphan Management:Files unique to the Left side are colored Blue (configurable).Files unique to the Right side are colored Pink/Red.Filtering: Users can define filters using glob patterns (e.g., *.o, node_modules/). These filters are passed to the jwalk iterator in the Core.Touch (Timestamp Sync): A specific command to copy the modification time from Source to Dest without copying the data. This is crucial for fixing "drift" in backups.5.2 Text Comparison & Merge Features3-Way Merge:Inputs: Left, Right, Center (Ancestor).Output: A fourth "Output" pane (or Bottom pane).Logic: The GUI must visualize the "Merge" state. Lines with conflicts are highlighted in Red. Lines auto-resolved are highlighted in Green/Yellow.Controls: The UI needs specific buttons in the gutter: "Take Left", "Take Right", "Take Both", "Take None".Editability: The Text View must be editable. This requires handling TextInput events in Slint and updating the underlying buffer. The Diff must be re-calculated dynamically (debounced) as the user types.5.3 Hex ComparisonView: A grid showing Offset (8 bytes), Hex (16 bytes), and ASCII (16 chars).Lazy Loading: Since binary files can be GBs in size, the Core must implement RandomAccess reading. The Slint ListView will request "Row 1000", and the Core will seek to 1000 * 16 bytes, read 16 bytes, and return the data.5.4 Image ComparisonModes:Fade: A slider that changes the opacity of the Top image over the Bottom image.Difference: Calculates abs(PixelA - PixelB) and renders the difference map (black = same, white = different).Swipe: A draggable divider where the left side shows Image A and the right side shows Image B.6. Initial Development Plan (Roadmap)This plan assumes a 20-week development cycle for a small team or a dedicated solo developer.Phase 1: The Core Foundation (Weeks 1-4)Objective: Establish the workspace and functional CLI scanner.Week 1: Scaffolding.Initialize Cargo workspace (core, cli, gui, common).Define Vfs trait and FileNode structs in common.Implement LocalVfs in core using std::fs.Week 2: The Scanner.Implement ScanSession using jwalk.Create the BTreeMap alignment logic (Left/Right pairing).Implement basic filters (ignore list).Week 3: Hashing & Comparison.Implement Hasher struct (BLAKE3 integration).Implement DiffComparator (Size, Time, Hash checks).Add caching logic (serialize results to .bin).Week 4: CLI Prototype.Build rcompare_cli.Implement commands: scan <left> <right>, report --json.Milestone: A CLI tool that outputs a JSON diff of two folders.Phase 2: The Basic GUI (Weeks 5-8)Objective: A Slint application that can browse folder differences.Week 5: Slint Integration.Set up rcompare_gui with a basic AppWindow.Create the "Thread Bridge" (channels between Main and Core threads).Week 6: The Virtual List.Implement the "Flattening" logic in Rust (Tree -> Vec).Create the FolderView component in Slint using ListView.Implement indentation rendering (padding based on depth).Week 7: Selection & Navigation.Add mouse selection (single/multi).Implement "Double Click to Dive" (change root).Add "Up Level" navigation.Week 8: Synchronization.Implement the dual-pane layout.Add scroll binding (Left scroll moves Right viewport).Milestone: A GUI that visualizes folder differences and allows synchronized scrolling.Phase 3: Text Diff Implementation (Weeks 9-13)Objective: Text comparison with syntax highlighting.Week 9: Diff Core.Integrate similar crate.Implement line-by-line diff generation (DiffLine struct).Week 10: Syntax & Rendering.Integrate syntect.Implement the Rust-side "Line to Colored Segments" converter.Create the TextDiffView in Slint.Week 11: The UI Gutter.Add line numbers.Add the central gutter map (overview of changes).Week 12: Intra-Line Diff.Implement the secondary diff pass for character highlighting.Refine colors (Red/Green backgrounds).Week 13: Optimization.Profile rendering performance.Implement caching for syntax-highlighted lines.Milestone: A functional Code Compare tool.Phase 4: File Operations & Safety (Weeks 14-17)Objective: Allow users to Copy, Move, and Delete.Week 14: Action Engine.Implement Copy, Move, Delete in Vfs.Add trash crate integration for safe deletion.Week 15: Concurrency Control.Implement a "Task Manager" in the UI (Progress Bars).Ensure file ops run in background threads to keep UI responsive.Week 16: Safety Rails.Implement "Confirm Dialogs".Implement read-only mode toggle.Week 17: Configuration.Implement Settings dialog (Ignore rules, Colors).Persist state to toml.Phase 5: Advanced Features & Release (Weeks 18-20)Objective: Hex, Image, and Polish.Week 18: Hex & Image.Implement basic Hex view (byte grid).Implement Image view (using image crate).Week 19: 3-Way Merge Logic.Implement the Base/Left/Right merge algebra.Week 20: Polish & CI.Fix bugs.Set up GitHub Actions for cross-platform builds.Create installers (MSI, Deb, DMG).Final Milestone: v1.0 Release.7. Technical Deep Dive: Implementation Details7.1 Data Structures for Slint IntegrationThe communication between Rust and Slint requires specific adapter patterns.The File Item Model:Slint cannot consume complex Rust structs directly. We must map them.Rust// Rust Side (rcompare_gui/src/models.rs)
#[derive(Clone)]
struct UiFileItem {
    name: SharedString,
    size: SharedString,
    date: SharedString,
    is_dir: bool,
    color: Color, // Computed based on DiffStatus
    depth: i32,
    expanded: bool,
}

// Slint Side (rcompare_gui/ui/types.slint)
export struct FileItem {
    name: string,
    size: string,
    date: string,
    is_dir: bool,
    color: color,
    depth: int,
    expanded: bool,
}
7.2 The Threading Model (Actor Pattern)To keep the UI responsive, rcompare_gui will spawn a dedicated CoreController thread.Channels:UI -> Core: Sender<GuiCommand> (e.g., Scan(path), Diff(file_id)).Core -> UI: slint::Weak::upgrade_in_event_loop closures.Cancellation:The Core must check an AtomicBool (shared state) inside tight loops (like hashing).If the user clicks "Cancel", the UI sets the flag to true, causing the Core to abort gracefully.7.3 Unsafe Code PolicyWhile Rust is safe, interacting with OS-specific file metadata (e.g., reflink copying on Btrfs/XFS or Windows ACLs) might require unsafe FFI calls.Constraint: All unsafe blocks must be encapsulated in the rcompare_common::sys module.Review: Any usage of unsafe requires double-check code review, adhering to the project's security stance.8. ConclusionRCompare represents a significant engineering challenge but offers a clear path to value. By adopting the Czkawka architecture—specifically the separation of core logic from the Slint interface—the project ensures maintainability and performance. The use of Rust guarantees that the application will be free of the memory safety classes of bugs that plague C++ legacy tools, while the detailed roadmap provides a structured approach to replicating the complex feature set of Beyond Compare.The resulting application will not only serve as a powerful tool for developers and system administrators but also as a reference implementation for complex, data-heavy desktop applications in the modern Rust ecosystem.9. Appendix: Requirements for AI Generation (Claude Code)(Use the following prompts to initialize the project with an AI coding assistant)Prompt 1: Workspace Setup"Create a Rust workspace named rcompare. It should contain four members: rcompare_core (lib), rcompare_gui (bin), rcompare_cli (bin), and rcompare_common (lib). Configure the root Cargo.toml to manage dependencies. Add thiserror, serde, and chrono to common. Add slint to gui. Add clap to cli."Prompt 2: VFS Trait"In rcompare_common, define a Vfs trait that supports read_dir, metadata, and open_file. Create a struct FileEntry with fields: path, size, modified (SystemTime), and is_dir. Ensure all are Send + Sync."Prompt 3: Core Scanner"In rcompare_core, implement a LocalVfs struct implementing the Vfs trait using std::fs. Then, create a FolderScanner struct that takes two paths (left, right), uses jwalk to traverse them in parallel, and returns a Vec<DiffNode> where DiffNode aligns the files by relative path."Prompt 4: Slint UI Prototype"In rcompare_gui, create a main.slint file. It should have a MainWindow with a HorizontalBox. Inside, place two StandardListView widgets separated by a rectangle (gutter). Define a struct FileItem in Slint and map it to a Rust model in main.rs. Populate the lists with dummy data."
